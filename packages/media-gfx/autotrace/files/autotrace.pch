This patch is for Autotrace 0.31.1.
It contains:

1) New input file format: GF font file, as generated by MetaFont.

2) New output file format: UGS, used in Metatype project.

3) Fixed two bugs, which caused unexpected aborts with 
diagnostics "zero determinant of C0*C1"
and "assertion error in line 1276 of fit.c".

With this patch, I successfully traced all glyphs of
TeX and TeX Math family. 

___
Serge Vakulenko <vak@cronyx.ru>


diff -u -N -b autotrace-0.31.1/Makefile.am autotrace/Makefile.am
--- autotrace-0.31.1/Makefile.am	Wed Oct 30 19:51:46 2002
+++ autotrace/Makefile.am	Thu May 22 13:32:50 2003
@@ -2,6 +2,7 @@
 EXTRA_DIST=$(man_MANS)						\
 output-swf.c output-swf.h					\
 input-magick.h input-magick.c input-png.c input-png.h		\
+input-gf.h input-gf.c						\
 output-pstoedit.c output-pstoedit.h				\
 autotrace-config.af autotrace-config.in				\
 autotrace.dsp autotrace.dsw					\
@@ -31,6 +32,7 @@
 input_src=input-pnm.c input-pnm.h \
 input-bmp.c input-bmp.h \
 input-tga.c input-tga.h \
+input-gf.c input-gf.h \
 $(input_png_src) \
 $(input_magick_src)

@@ -50,6 +52,7 @@
 output-fig.c  output-fig.h \
 output-sk.c output-sk.h \
 output-svg.c output-svg.h \
+output-ugs.c output-ugs.h \
 output-p2e.c output-p2e.h \
 output-emf.c output-emf.h \
 output-dxf.c output-dxf.h \
diff -u -N -b autotrace-0.31.1/autotrace.c autotrace/autotrace.c
--- autotrace-0.31.1/autotrace.c	Sun Nov  3 21:25:16 2002
+++ autotrace/autotrace.c	Wed May 21 20:52:20 2003
@@ -81,6 +81,7 @@
   at_input_opts_type * opts;
   XMALLOC(opts, sizeof(at_input_opts_type));
   opts->background_color = NULL;
+  opts->charcode = 0;
   return opts;
 }

@@ -89,6 +90,7 @@
 {
   at_input_opts_type * opts;
   opts = at_input_opts_new();
+  *opts = *original;
   if (original->background_color)
     opts->background_color = at_color_copy(original->background_color);
   return opts;
diff -u -N -b autotrace-0.31.1/autotrace.h autotrace/autotrace.h
--- autotrace-0.31.1/autotrace.h	Fri Nov  8 20:39:04 2002
+++ autotrace/autotrace.h	Wed May 21 20:35:42 2003
@@ -123,6 +123,11 @@
 "default is no background color.")
   at_color_type *background_color;

+#define at_doc__charcode							\
+N_("charcode <unsigned>: code of character to load from GF file, "	\
+"allowed are 0..255; default is the first character in font.")
+  unsigned charcode;
+
 #define at_doc__color_count							\
 N_("color-count <unsigned>: number of colors a color bitmap is reduced to, "	\
 "it does not work on grayscale, allowed are 1..256; "				\
@@ -205,6 +210,7 @@
 struct _at_input_opts_type
 {
   at_color_type *background_color;
+  unsigned charcode;		/* Character code used only in GF input.*/
 };

 struct _at_output_opts_type
diff -u -N -b autotrace-0.31.1/fit.c autotrace/fit.c
--- autotrace-0.31.1/fit.c	Sun Nov  3 21:42:10 2002
+++ autotrace/fit.c	Thu May 22 15:42:28 2003
@@ -110,6 +110,7 @@
   fitting_opts_type fitting_opts;

   fitting_opts.background_color = NULL;
+  fitting_opts.charcode = 0;
   fitting_opts.color_count = 0;
   fitting_opts.corner_always_threshold = (at_real) 60.0;
   fitting_opts.corner_surround = 4;
@@ -1279,14 +1280,15 @@
   C0_C1_det = C[0][0] * C[1][1] - C[1][0] * C[0][1];
   if (C0_C1_det == 0.0)
     {
-      LOG ("zero determinant of C0*C1");
-      at_exception_fatal(exception, "zero determinant of C0*C1");
-      goto cleanup;
+      /* Zero determinant */
+      alpha1 = 0;
+      alpha2 = 0;
     }
-
+  else
+    {
   alpha1 = X_C1_det / C0_C1_det;
   alpha2 = C0_X_det / C0_C1_det;
-
+    }
   CONTROL1 (spline) = Vadd_point (START_POINT (spline),
                                   Vmult_scalar (t1_hat, alpha1));
   CONTROL2 (spline) = Vadd_point (END_POINT (spline),
@@ -1320,7 +1322,8 @@
       CURVE_T (curve, p) = CURVE_T (curve, p - 1) + d;
     }

-  assert (LAST_CURVE_T (curve) != 0.0);
+  if (LAST_CURVE_T (curve) == 0.0)
+    LAST_CURVE_T (curve) = 1.0;

   for (p = 1; p < CURVE_LENGTH (curve); p++)
     CURVE_T (curve, p) = CURVE_T (curve, p) / LAST_CURVE_T (curve);
diff -u -N -b autotrace-0.31.1/input-gf.c autotrace/input-gf.c
--- autotrace-0.31.1/input-gf.c	Thu Jan  1 03:00:00 1970
+++ autotrace/input-gf.c	Thu May 22 19:02:53 2003
@@ -0,0 +1,720 @@
+/* input-gf.c: import TeX raster font files.
+
+   Copyright (C) 2003 Serge Vakulenko <vak@cronyx.ru>.
+
+   This file is based on sources of Fontutils package
+   by Karl Berry and Kathryn Hargreaves.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+   USA. */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif /* Def: HAVE_CONFIG_H */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "input-gf.h"
+#include "output-ugs.h"
+#include "bitmap.h"
+
+#define WHITE		0
+
+/*
+ * GF opcodes.
+ */
+#define POST		248
+#define POST_POST	249
+
+#define GF_SIGNATURE	223
+#define GF_ID		131
+
+#define BOC		67
+#define BOC1		68
+#define EOC		69
+
+#define PAINT_0		0
+#define PAINT_63	63
+#define PAINT1		64
+#define PAINT2		65
+#define PAINT3		66
+
+#define SKIP0		70
+#define SKIP1		71
+#define SKIP2		72
+#define SKIP3		73
+
+#define NEW_ROW_0	74
+#define NEW_ROW_164	238
+
+#define XXX1		239
+#define XXX2		240
+#define XXX3		241
+#define XXX4		242
+#define YYY		243
+
+#define NO_OP		244
+
+#define CHAR_LOC	245
+#define CHAR_LOC0	246
+
+typedef struct _gf_char_t {
+	unsigned char	charcode;
+	long		h_escapement;
+	long		tfm_width;
+	long		char_pointer;
+} gf_locator_t;
+
+typedef struct _gf_font_t {
+	char *		input_filename;
+	FILE *		input_file;
+	double		design_size;
+	unsigned long	checksum;
+	double		h_pixels_per_point, v_pixels_per_point;
+	long		bbox_min_col;
+	long		bbox_max_col;
+	long		bbox_min_row;
+	long		bbox_max_row;
+	gf_locator_t	char_loc [256];
+} gf_font_t;
+
+/* The characters are the most important information in the GF file. */
+
+typedef struct {
+	gf_font_t *	font;
+	unsigned char	charcode;
+	long		bbox_min_col;
+	long		bbox_max_col;
+	long		bbox_min_row;
+	long		bbox_max_row;
+	long		h_escapement;
+	long		tfm_width;
+	unsigned short	height, width;
+	char *		bitmap;
+} gf_char_t;
+
+/* This is the pixel at [ROW,COL]. */
+#define PIXEL(s,r,c)	(s)->bitmap [(r) * (s)->width + (c)]
+
+static unsigned char
+get_byte (gf_font_t *font)
+{
+	unsigned char b;
+
+	if (fread (&b, 1, 1, font->input_file) != 1) {
+		fprintf (stderr, "%s: read error\n", font->input_filename);
+		exit (-1);
+	}
+	return b;
+}
+
+static unsigned short
+get_two (gf_font_t *font)
+{
+	unsigned short b;
+
+	b = (unsigned short) get_byte (font) << 8;
+	b |= get_byte (font);
+	return b;
+}
+
+/*
+ * C does not provide an obvious type for a 24-bit quantity, so we
+ * return a 32-bit one.
+ */
+static unsigned long
+get_three (gf_font_t *font)
+{
+	unsigned long b;
+
+	b = (unsigned long) get_byte (font) << 16;
+	b |= (unsigned long) get_byte (font) << 8;
+	b |= get_byte (font);
+	return b;
+}
+
+static unsigned long
+get_four (gf_font_t *font)
+{
+	unsigned long b;
+
+	b = (unsigned long) get_byte (font) << 24;
+	b |= (unsigned long) get_byte (font) << 16;
+	b |= (unsigned long) get_byte (font) << 8;
+	b |= get_byte (font);
+	return b;
+}
+
+static void
+move_relative (gf_font_t *font, long count)
+{
+	if (fseek (font->input_file, count, SEEK_CUR) < 0) {
+		fprintf (stderr, "%s: seek error\n", font->input_filename);
+		exit (-1);
+	}
+}
+
+static unsigned char
+get_previous_byte (gf_font_t *font)
+{
+	unsigned char b;
+
+	move_relative (font, -1);
+	b = get_byte (font);
+	move_relative (font, -1);
+	return b;
+}
+
+static unsigned long
+get_previous_four (gf_font_t *font)
+{
+	unsigned long b;
+
+	move_relative (font, -4);
+	b = get_four (font);
+	move_relative (font, -4);
+	return b;
+}
+
+
+/*
+ * Skip all specials, leaving the file pointer at the first non-special.
+ * We do not save the specials, though.
+ */
+static void
+skip_specials (gf_font_t *font)
+{
+	for (;;) {
+		switch (get_byte (font)) {
+		case XXX1:
+			move_relative (font, get_byte (font));
+			continue;
+		case XXX2:
+			move_relative (font, get_two (font));
+			continue;
+		case XXX3:
+			move_relative (font, get_three (font));
+			continue;
+		case YYY:
+			(void) get_four (font);
+			continue;
+		default:
+			move_relative (font, -1);
+			return;
+		}
+	}
+}
+
+/*
+ * The ``bitmap'' is a sequence of commands that describe it in terms of
+ * run-length encoding.
+ *
+ * GF's row and column numbers are the lower left corner of a pixel.
+ * GF (0,0) is the Cartesian unit square: 0 <= x (col) <= 1,
+ * 0 <= y (row) <= 1.  Yes, it's <=, not <.  What does this mean for
+ * the maxes and mins?  Let's take the height first:  if a character has
+ * min_row = 0 and max_row = 10, we start the ``current'' y at 10,
+ * (possibly) paint some pixels on that row, ..., and end up with it at
+ * zero, (possibly) painting some pixels on that row.  Thus, there are
+ * 11 (10 - 0 + 1) rows in which we might paint pixels.  Now the width:
+ * if a character has min_row = 0 and max_row = 4, the current x starts
+ * at zero, we paint four pixels (let's say), and now the current x is
+ * four (the max possible), so we cannot paint any more.  Thus there are
+ * four (4 - 0) columns in which we might paint pixels.
+ *
+ * Weird, huh?
+ */
+static void
+get_character_bitmap (gf_char_t *sym)
+{
+	unsigned char c;
+
+	/* We expect these to be >= 0, but if the GF file is improper,
+	 * they might turn to be negative.
+	 */
+	int height, width, painting_black = 0;
+	int cur_x, cur_y;		/* This will be the GF position. */
+
+	cur_x = sym->bbox_min_col;
+	cur_y = sym->bbox_max_row;
+
+	width = sym->bbox_max_col - sym->bbox_min_col;
+	height = sym->bbox_max_row - sym->bbox_min_row + 1;
+
+	/* If the character has zero or negative extent in either dimension,
+	 * it's not going to have a bitmap.  (If this happens, the GF file is
+	 * incorrect; but the discrepancy isn't serious, so we may as well not
+	 * bomb out when it happens, especially since PKtoGF has a bug that
+	 * produces such a bounding box when the character is all blank.)
+	 */
+	if (width <= 0 || height <= 0) {
+		sym->height = 0;
+		sym->width = 0;
+		sym->bitmap = 0;
+
+		/* The next non-NO_OP byte should be EOC. */
+		while ((c = get_byte (sym->font)) == NO_OP)
+			continue;	/* do nothing */
+		if (c != EOC) {
+			fprintf (stderr, "%s: expected eoc (for a blank character), found %u\n",
+				sym->font->input_filename, c);
+			exit (-1);
+		}
+		return;
+	}
+
+	sym->height = height;
+	sym->width = width;
+	sym->bitmap = calloc (width, height);
+	if (! sym->bitmap) {
+		fprintf (stderr, "%s: out of memory\n",
+			sym->font->input_filename);
+		exit (-1);
+	}
+
+	for (;;) {
+		c = get_byte (sym->font);
+		if (c == EOC)
+			break;
+
+		if (/* PAINT_0 <= c && */ c <= PAINT3) {
+			/* No need to test if `PAINT_0 <= c'; it must be,
+			 * since PAINT_0 is zero and `c' is unsigned.
+			 */
+			/* The paint commands come in two varieties -- either
+			 * with the length implicitly part of the command,
+			 * or where it is specified as a separate parameter. */
+			unsigned length;
+
+			if (/* PAINT_0 <= c && */ c <= PAINT_63)
+				length = c - PAINT_0;
+			else {
+				switch (c) {
+				case PAINT1:
+					length = get_byte (sym->font);
+					break;
+				case PAINT2:
+					length = get_two (sym->font);
+					break;
+				case PAINT3:
+					length = get_three (sym->font);
+					break;
+				default:
+					fprintf (stderr, "%s: invalid painting command %u\n",
+						sym->font->input_filename, c);
+					exit (-1);
+				}
+			}
+
+			/* We have to translate from Cartesian to
+			 * C coordinates.  That means the x's are the same,
+			 * but the y's are flipped. */
+			if (painting_black) {
+				unsigned matrix_x, matrix_y;
+
+				matrix_y = sym->bbox_max_row - cur_y;
+				for (; length != 0; length--) {
+					matrix_x = cur_x - sym->bbox_min_col;
+
+					PIXEL (sym, matrix_y, matrix_x) = 255;
+					cur_x++;
+				}
+			} else {
+				cur_x += length;
+			}
+			painting_black = ! painting_black;
+
+		} else if (SKIP0 <= c && c <= SKIP3) {
+			/* Skip commands move down in the GF character,
+			 * leaving blank rows. */
+			unsigned rows_to_skip;
+
+			switch (c) {
+			case SKIP0:
+				rows_to_skip = 0;
+				break;
+			case SKIP1:
+				rows_to_skip = get_byte (sym->font);
+				break;
+			case SKIP2:
+				rows_to_skip = get_two (sym->font);
+				break;
+			case SKIP3:
+				rows_to_skip = get_three (sym->font);
+				break;
+			default:
+				fprintf (stderr, "%s: invalid skip command %u\n",
+					sym->font->input_filename, c);
+				exit (-1);
+			}
+			cur_y -= rows_to_skip + 1;
+			cur_x = sym->bbox_min_col;
+			painting_black = 0;
+
+		} else if (NEW_ROW_0 <= c && c <= NEW_ROW_164) {
+			/* `new_row' commands move to the next line down
+			 * and then over. */
+			cur_y--;
+			cur_x = sym->bbox_min_col + c - NEW_ROW_0;
+			painting_black = 1;
+
+		} else if (c == NO_OP) {
+			/* do nothing */
+
+		} else if ((XXX1 <= c && c <= XXX4) || c == YYY) {
+			skip_specials (sym->font);
+
+		} else {
+			fprintf (stderr, "%s: expected paint or skip or new_row, found %u\n",
+				sym->font->input_filename, c);
+			exit (-1);
+		}
+	}
+}
+
+/*
+ * The GF format does not guarantee that the bounding box is the
+ * smallest possible, i.e., that the character bitmap does not have
+ * blank rows or columns at an edge.  We want to remove such blanks.
+ */
+static void
+deblank (gf_char_t *sym)
+{
+	unsigned all_white, white_on_left = 0, white_on_right = 0,
+		white_on_top = 0, white_on_bottom = 0;
+	int c, r; /* int in case GF_CHAR is zero pixels wide. */
+
+	/* Let's start with blank columns at the left-hand side. */
+	all_white = 1;
+	for (c=0; c < sym->width && all_white; c++) {
+		for (r=0; r < sym->height && all_white; r++) {
+			if (PIXEL (sym, r, c) != WHITE)
+				all_white = 0;
+		}
+		if (all_white)
+			white_on_left++;
+	}
+
+	/* Now let's check the right-hand side. */
+	all_white = 1;
+	for (c = sym->width - 1; c >= 0 && all_white; c--) {
+		for (r=0; r < sym->height && all_white; r++) {
+			if (PIXEL (sym, r, c) != WHITE)
+				all_white = 0;
+		}
+		if (all_white)
+			white_on_right++;
+	}
+
+	/* Check for all-white rows on top now. */
+	all_white = 1;
+	for (r=0; r < sym->height && all_white; r++) {
+		for (c=0; c < sym->width && all_white; c++) {
+			if (PIXEL (sym, r, c) != WHITE)
+				all_white = 0;
+		}
+		if (all_white)
+			white_on_top++;
+	}
+
+	/* And, last, for all-white rows on the bottom. */
+	all_white = 1;
+	for (r = sym->height - 1; r >= 0 && all_white; r--) {
+		for (c=0; c < sym->width && all_white; c++) {
+			if (PIXEL (sym, r, c) != WHITE)
+				all_white = 0;
+		}
+		if (all_white)
+			white_on_bottom++;
+	}
+
+	/* If we have to remove columns at either the left or the right, we
+	 * have to reallocate the memory, since much code depends on the fact
+	 * that the bitmap is in contiguous memory.  If we have to remove
+	 * rows, we don't necessarily have to reallocate the memory, but we
+	 * might as well, to save space.
+	 */
+	if (white_on_left > 0 || white_on_right > 0 ||
+	    white_on_top > 0 || white_on_bottom > 0) {
+		gf_char_t condensed;
+
+		if (white_on_left + white_on_right > sym->width) {
+			/* The character was entirely blank. */
+			sym->width = 0;
+			sym->height = 0;
+			sym->bbox_min_col = 0;
+			sym->bbox_max_col = 0;
+			sym->bbox_min_row = 0;
+			sym->bbox_max_row = 0;
+			condensed.bitmap = 0;
+		} else {
+			condensed.width = sym->width - white_on_left - white_on_right;
+			condensed.height = sym->height - white_on_top - white_on_bottom;
+			condensed.bitmap = calloc (condensed.width,
+				condensed.height);
+			if (! condensed.bitmap) {
+				fprintf (stderr, "%s: out of memory\n",
+					sym->font->input_filename);
+				exit (-1);
+			}
+			for (r=0; r < condensed.height; r++)
+				for (c=0; c < condensed.width; c++) {
+					PIXEL (&condensed, r, c) =
+						PIXEL (sym, r + white_on_top,
+							c + white_on_left);
+				}
+			sym->bbox_min_row += white_on_bottom;
+			sym->bbox_max_row -= white_on_top;
+			sym->bbox_min_col += white_on_left;
+			sym->bbox_max_col -= white_on_right;
+		}
+		if (sym->bitmap)
+			free (sym->bitmap);
+		sym->bitmap = condensed.bitmap;
+	}
+}
+
+static int
+gf_open (gf_font_t *font, char *filename)
+{
+	unsigned char b, c;
+	unsigned long post_ptr;
+
+	font->input_filename = filename;
+	font->input_file = fopen (filename, "r");
+	if (! font->input_file) {
+		perror (filename);
+		return 0;
+        }
+
+	if (fseek (font->input_file, 0, SEEK_END) < 0) {
+		perror (filename);
+		return 0;
+	}
+	/* Check that file is not empty, because we are trying
+	 * to seek before the beginning. */
+	if (ftell (font->input_file) <= 0) {
+		fprintf (stderr, "%s: empty file\n", font->input_filename);
+		return 0;
+	}
+
+	do
+		b = get_previous_byte (font);
+	while (b == GF_SIGNATURE);
+	if (b != GF_ID) {
+		fprintf (stderr, "%s: invalid signature (expected %u, found %u)\n",
+			font->input_filename, GF_ID, b);
+		return 0;
+	}
+
+	post_ptr = get_previous_four (font);
+	for (c=0; ; c++) {
+		font->char_loc[c].charcode = c;
+		font->char_loc[c].tfm_width = 0;
+		font->char_loc[c].char_pointer = -1;
+		if (c == 255)
+			break;
+	}
+
+	fseek (font->input_file, post_ptr, SEEK_SET);
+	b = get_byte (font);
+	if (b != POST) {
+		fprintf (stderr, "%s: invalid font structure (expected %u, found %u)\n",
+			font->input_filename, POST, b);
+		return 0;
+	}
+	get_four (font);		/* Ignore the special pointer. */
+
+	font->design_size = get_four (font) / (double) (1L << 20);
+	font->checksum = get_four (font);
+
+	/* The resolution values are stored in the file as pixels per point,
+	   scaled by 2^16. */
+	font->h_pixels_per_point = get_four (font) / (double) (1L << 16);
+	font->v_pixels_per_point = get_four (font) / (double) (1L << 16);
+
+	font->bbox_min_col = (signed long) get_four (font);
+	font->bbox_max_col = (signed long) get_four (font);
+	font->bbox_min_row = (signed long) get_four (font);
+	font->bbox_max_row = (signed long) get_four (font);
+
+	/* We do not know in advance how many character locators exist,
+	 * but we do place a maximum on it (contrary to what the GF format
+	 * definition says), namely, MAX_CHARCODE. */
+	for (;;) {
+		b = get_byte (font);
+		if (b == POST_POST)
+			break;
+
+		c = get_byte (font);
+
+		if (b == CHAR_LOC) {
+			font->char_loc[c].h_escapement =
+				(double) get_four (font) / (1 << 16) + .5;
+			/* Ignore vertical escapement. */
+			(void) get_four (font);
+
+		} else if (b == CHAR_LOC0) {
+			font->char_loc[c].h_escapement = get_byte (font);
+
+		} else {
+			fprintf (stderr, "%s: invalid char_loc command (found %u)\n",
+				font->input_filename, b);
+			return 0;
+		}
+
+		font->char_loc[c].tfm_width = get_four (font);
+		font->char_loc[c].char_pointer = get_four (font);
+	}
+	return 1;
+}
+
+/*
+ * Get any character by its code.
+ */
+static int
+gf_get_char (gf_font_t *font, gf_char_t *sym, unsigned char charcode)
+{
+	gf_locator_t *loc;
+	unsigned char c, col_delta, row_delta;
+	long lcode, back_pointer;
+
+	loc = &font->char_loc [charcode];
+	if (loc->char_pointer == -1)
+		return 0;
+
+	sym->font = font;
+	sym->h_escapement = loc->h_escapement;
+	sym->tfm_width = loc->tfm_width;
+
+	if (fseek (font->input_file, loc->char_pointer, SEEK_SET) < 0) {
+		fprintf (stderr, "%s: seek error\n", font->input_filename);
+		return 0;
+	}
+
+	/* This reads the character starting from the current position
+	 * (but some specials might come first).
+	 */
+	skip_specials (font);
+
+	c = get_byte (font);
+	switch (c) {
+	case BOC:
+		/* If the back pointer actually points somewhere,
+		 * this character is a ``residue'', and the font
+		 * is probably too big.
+		 */
+		lcode = (long) get_four (font);
+		if (lcode < 0 || lcode > 255) {
+			/* Someone is trying to use a font with character codes
+			 * that are out of our range. */
+			fprintf (stderr, "%s: invalid character code %ld (expected %d)\n",
+				font->input_filename, lcode, charcode);
+			return 0;
+		}
+		sym->charcode = lcode;
+
+		back_pointer = (long) get_four (font);
+		if (back_pointer != -1)
+			fprintf (stderr, "%s: warning: character %u has a non-null back pointer (to %#lx)\n",
+				font->input_filename, sym->charcode, back_pointer);
+
+		sym->bbox_min_col = (long) get_four (font);
+		sym->bbox_max_col = (long) get_four (font);
+		sym->bbox_min_row = (long) get_four (font);
+		sym->bbox_max_row = (long) get_four (font);
+		break;
+
+	case BOC1:
+		sym->charcode = get_byte (font);
+
+		col_delta = get_byte (font);
+		sym->bbox_max_col = get_byte (font);
+		sym->bbox_min_col = sym->bbox_max_col - col_delta;
+
+		row_delta = get_byte (font);
+		sym->bbox_max_row = get_byte (font);
+		sym->bbox_min_row = sym->bbox_max_row - row_delta;
+		break;
+
+	case POST:
+		return 0;
+
+	default:
+		fprintf (stderr, "%s: error reading character (found %u)\n",
+			font->input_filename, c);
+		return 0;
+	}
+	if (sym->charcode != charcode) {
+		fprintf (stderr, "%s: warning: character code mismatch, %d != %d\n",
+			font->input_filename, sym->charcode, charcode);
+	}
+
+	get_character_bitmap (sym);
+
+	deblank (sym);
+	return 1;
+}
+
+at_bitmap_type input_gf_reader (at_string filename, at_input_opts_type *opts,
+	at_msg_func msg_func, at_address msg_data)
+{
+	at_exception_type exp = at_exception_new (msg_func, msg_data);
+	at_bitmap_type bitmap = at_bitmap_init (NULL, 0, 0, 0);
+	gf_font_t fontdata, *font = &fontdata;
+	gf_char_t chardata, *sym = &chardata;
+	unsigned int i, j, ptr;
+
+	if (! gf_open (font, filename)) {
+		at_exception_fatal (&exp, "Cannot open input GF file");
+		return bitmap;
+        }
+	if (opts->charcode == 0) {
+		/* Find a first character in font file. */
+		for (i=0; i<256; ++i)
+			if (font->char_loc[i].char_pointer != -1)
+				break;
+		if (i >= 256) {
+			at_exception_fatal (&exp, "No characters in input GF file");
+			return bitmap;
+		}
+		opts->charcode = i;
+	}
+	if (! gf_get_char (font, sym, (unsigned char) opts->charcode)) {
+		fclose (font->input_file);
+		at_exception_fatal (&exp, "Error reading character from GF file");
+		return bitmap;
+	}
+
+	ugs_design_pixels = font->design_size * font->v_pixels_per_point + 0.5;
+	ugs_charcode = opts->charcode;
+	ugs_advance_width = sym->h_escapement;
+	ugs_left_bearing = sym->bbox_min_col;
+	ugs_descend = sym->bbox_min_row;
+	ugs_max_col = sym->bbox_max_col;
+	ugs_max_row = sym->bbox_max_row;
+
+	bitmap = at_bitmap_init (NULL, sym->width, sym->height, 1);
+	for (j=0, ptr=0; j<sym->height; j++) {
+		for (i=0; i<sym->width; i++) {
+			AT_BITMAP_BITS (bitmap) [ptr++] = PIXEL (sym, j, i);
+		}
+	}
+	if (sym->bitmap)
+		free (sym->bitmap);
+	fclose (font->input_file);
+	return bitmap;
+}
diff -u -N -b autotrace-0.31.1/input-gf.h autotrace/input-gf.h
--- autotrace-0.31.1/input-gf.h	Thu Jan  1 03:00:00 1970
+++ autotrace/input-gf.h	Wed May 21 20:18:21 2003
@@ -0,0 +1,31 @@
+/* input-gf.h: import TeX raster font files
+
+   Copyright (C) 2003 Serge Vakulenko <vak@cronyx.ru>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+   USA. */
+
+#ifndef INPUT_GF_H
+#define INPUT_GF_H
+
+#include "input.h"
+
+
+at_bitmap_type input_gf_reader (at_string filename,
+				 at_input_opts_type * opts,
+				 at_msg_func msg_func,
+				 at_address msg_data);
+
+#endif /* not INPUT_GF_H */
diff -u -N -b autotrace-0.31.1/input.c autotrace/input.c
--- autotrace-0.31.1/input.c	Wed Nov  6 21:42:02 2002
+++ autotrace/input.c	Wed May 21 20:19:45 2003
@@ -26,6 +26,7 @@
 #include "input-pnm.h"
 #include "input-bmp.h"
 #include "input-tga.h"
+#include "input-gf.h"
 #ifdef HAVE_LIBPNG
 #include "input-png.h"
 #endif /* HAVE_LIBPNG */
@@ -57,6 +58,7 @@
   { "PGM",   "Portable graymap format",        input_pnm_reader },
   { "PPM",   "Portable pixmap format",         input_pnm_reader },
   { "BMP",   "Microsoft Windows bitmap image", input_bmp_reader },
+  { "GF",    "TeX raster font",                input_gf_reader },
   END
 };

diff -u -N -b autotrace-0.31.1/main.c autotrace/main.c
--- autotrace-0.31.1/main.c	Thu Oct 31 07:28:20 2002
+++ autotrace/main.c	Thu May 22 19:24:22 2003
@@ -127,6 +127,7 @@
   if (input_reader != NULL)
     {
       input_opts = at_input_opts_new ();
+      input_opts->charcode = fitting_opts->charcode;
       if (fitting_opts->background_color)
 	input_opts->background_color = at_color_copy(fitting_opts->background_color);

@@ -189,6 +190,7 @@
   should be ignored, for example FFFFFF;\n\
   default is no background color.\n\
 centerline: trace a character's centerline, rather than its outline.\n\
+charcode <unsigned>: code of character to load from GF font file.\n\
 color-count <unsigned>: number of colors a color bitmap is reduced to,\n\
   it does not work on grayscale, allowed are 1..256;\n\
   default is 0, that means not color reduction is done.\n\
@@ -249,6 +251,7 @@
 	{ "debug-arch",                 0, 0, 0 },
 	{ "debug-bitmap",               0, (int *)&dumping_bitmap, 1 },
         { "centerline",			0, 0, 0 },
+	{ "charcode",			1, 0, 0 },
         { "color-count",                1, 0, 0 },
         { "corner-always-threshold",    1, 0, 0 },
         { "corner-surround",            1, 0, 0 },
@@ -300,6 +303,9 @@
       else if (ARGUMENT_IS ("centerline"))
 	fitting_opts->centerline = true;

+      else if (ARGUMENT_IS ("charcode"))
+	fitting_opts->charcode = strtoul (optarg, 0, 0);
+
       else if (ARGUMENT_IS ("color-count"))
         fitting_opts->color_count = atou (optarg);

diff -u -N -b autotrace-0.31.1/output-ugs.c autotrace/output-ugs.c
--- autotrace-0.31.1/output-ugs.c	Thu Jan  1 03:00:00 1970
+++ autotrace/output-ugs.c	Thu May 22 19:41:42 2003
@@ -0,0 +1,303 @@
+/* output-ugs.h - output in UGS format
+
+   Copyright (C) 2003 Serge Vakulenko <vak@cronyx.ru>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+   USA. */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif /* Def: HAVE_CONFIG_H */
+
+#include "spline.h"
+#include "color.h"
+#include "output-ugs.h"
+
+long ugs_design_pixels;		/*  A design size of font in pixels. */
+
+long ugs_charcode;
+long ugs_advance_width;
+long ugs_left_bearing, ugs_descend;
+long ugs_max_col, ugs_max_row;
+
+static long lowerx, upperx, lowery, uppery;
+
+static int round (double x)
+{
+	if (x < 0)
+		return - (int) (-x + 0.5);
+	return (int) (x + 0.5);
+}
+
+static int compute_determinant (double *det, double a, double b,
+	double c, double d)
+{
+	double lensq;
+
+	*det = a * d - b * c;
+	lensq = (a*a + b*b) * (c*c + d*d);
+	if (lensq < 1 || *det * *det * 4000000 < lensq)
+		return 0;
+	return 1;
+}
+
+static void cubic_to_quadratic (double ax, double ay, double bx, double by,
+	double cx, double cy, double dx, double dy,
+	double *fx, double *fy, double *ex, double *ey, double *gx, double *gy)
+{
+	double t, t1, det, tanx, tany, s, tw1, tw2;
+
+	/* Find the twist point. If no, then use 1/2. */
+	tw1 = -ax + 2*bx - cx;
+	tw2 = -ax + 3*bx - 3*cx + dx;
+	if (tw2 < 0) {
+		tw1 = -tw1;
+		tw2 = -tw2;
+	}
+	if (tw1 > 0.001 && tw1 < tw2) {
+		t = tw1 / tw2;
+	} else {
+		tw1 = -ay + 2*by - cy;
+		tw2 = -ay + 3*by - 3*cy + dy;
+		if (tw2 < 0) {
+			tw1 = -tw1;
+			tw2 = -tw2;
+		}
+		if (tw1 > 0.001 && tw1 < tw2) {
+			t = tw1 / tw2;
+		} else
+			t = 0.5;
+	}
+	t1 = 1 - t;
+
+	/* Compute the point E way t from x to y, along the curve. */
+	*ex = ax*t1*t1*t1 + 3*bx*t*t1*t1 + 3*cx*t*t*t1 + dx*t*t*t;
+	*ey = ay*t1*t1*t1 + 3*by*t*t1*t1 + 3*cy*t*t*t1 + dy*t*t*t;
+
+	/* Compute the tangent at point E. */
+	tanx = 3 * (-ax*t1*t1 + bx*t1*(1-3*t) + cx*t*(2-3*t) + dx*t*t);
+	tany = 3 * (-ay*t1*t1 + by*t1*(1-3*t) + cy*t*(2-3*t) + dy*t*t);
+
+	/* Find point F as an intersection of AB and tangent at E.
+	 * Solving a system:
+	 * (B-A) t + (D+C-B-A) * s = (E-A) */
+	if (compute_determinant (&det, bx - ax, by - ay, tanx, tany)) {
+		compute_determinant (&s, *ex - ax, *ey - ay, tanx, tany);
+		s /= det;
+		if (s < 0)
+			s = 0;
+
+		*fx = bx * s + ax * (1-s);
+		*fy = by * s + ay * (1-s);
+	} else {
+		/* Cannot solve, let F be equal E. */
+		*fx = *ex;
+		*fy = *ey;
+	}
+
+	/* Find point G as an intersection of CD and tangent at E.
+	 * Solving a system:
+	 * (C-D) t + (A+B-C-D) * s = (E-D) */
+	if (compute_determinant (&det, cx - dx, cy - dy, -tanx, -tany)) {
+		compute_determinant (&s, *ex - dx, *ey - dy, -tanx, -tany);
+		s /= det;
+		if (s < 0)
+			s = 0;
+
+		*gx = cx * s + dx * (1-s);
+		*gy = cy * s + dy * (1-s);
+	} else {
+		/* Cannot solve, let G be equal E. */
+		*gx = *ex;
+		*gy = *ey;
+	}
+}
+
+#if CUBIC
+static void
+output_contour (FILE *file, FILE *tracer, unsigned height)
+{
+	int x, lastx;
+
+	fprintf (file, "\tcontour\n");
+	for (lastx=0; (x = getc (tracer)) >= 0; lastx = x) {
+		double x1, y1, x1a, y1a, x3a, y3a, x3, y3;
+
+		if (x != 'M' || lastx != '"')
+			continue;
+
+		if (fscanf (tracer, "%lg%lg", &x1, &y1) != 2)
+			FATAL ("Autotrace format error");
+		y1 = height - y1;
+
+		fprintf (file, "\t\tpath\n");
+		fprintf (file, "\t\t\tmove %g %g\n", x1, y1);
+
+		while ((x = getc (tracer)) >= 0) {
+			if (x == 'L') {
+				if (fscanf (tracer, "%lg%lg", &x3, &y3) != 2)
+					FATAL ("Autotrace format error");
+				y3 = height - y3;
+				fprintf (file, "\t\t\tline %g %g\n", x3, y3);
+			} else if (x == 'C') {
+				if (fscanf (tracer, "%lg%lg%lg%lg%lg%lg",
+				    &x1a, &y1a, &x3a, &y3a, &x3, &y3) != 6)
+					FATAL ("Autotrace format error");
+				y1a = height - y1a;
+				y3a = height - y3a;
+				y3 = height - y3;
+				fprintf (file, "\t\t\tcurve %g %g %g %g %g %g\n",
+					x1a, y1a, x3a, y3a, x3, y3);
+			} else
+				break;
+		}
+		fprintf (file, "\t\tend path\n");
+	}
+	fprintf (file, "\tend contour\n");
+}
+#endif
+
+static void output_splines (FILE *file, spline_list_array_type shape,
+	int height)
+{
+	unsigned l, s;
+	spline_list_type list;
+	spline_type first, t;
+	int x, lastx;
+	double x1, y1, x1a, y1a, x2, y2, x3a, y3a, x3, y3;
+	int ix1, iy1, ix1a, iy1a, ix2, iy2, ix3a, iy3a, ix3, iy3;
+
+	fprintf (file, "\tcontour\n");
+	for (l = 0; l < SPLINE_LIST_ARRAY_LENGTH (shape); l++) {
+		list = SPLINE_LIST_ARRAY_ELT (shape, l);
+		first = SPLINE_LIST_ELT (list, 0);
+
+		x1 = START_POINT (first).x + ugs_left_bearing;
+		y1 = START_POINT (first).y + ugs_descend;
+		ix1 = round (x1);
+		iy1 = round (y1);
+
+		fprintf (file, "\t\tpath\n");
+		fprintf (file, "\t\t\tdot-on %d %d\n", ix1, iy1);
+
+		if (lowerx > ix1) lowerx = ix1;
+		if (lowery > iy1) lowery = iy1;
+		if (upperx < ix1) upperx = ix1;
+		if (uppery < iy1) uppery = iy1;
+
+		for (s = 0; s < SPLINE_LIST_LENGTH (list); s++) {
+			t = SPLINE_LIST_ELT (list, s);
+
+			if (SPLINE_DEGREE(t) == LINEARTYPE) {
+				x3 = END_POINT(t).x + ugs_left_bearing;
+				y3 = END_POINT(t).y + ugs_descend;
+				ix3 = round (x3);
+				iy3 = round (y3);
+
+				if (! (ix3 == round(x1) && iy3 == round(y1)))
+					fprintf (file, "\t\t\tdot-on %d %d\n",
+						ix3, iy3);
+
+				if (lowerx > ix3) lowerx = ix3;
+				if (lowery > iy3) lowery = iy3;
+				if (upperx < ix3) upperx = ix3;
+				if (uppery < iy3) uppery = iy3;
+			} else {
+				x1a = CONTROL1(t).x + ugs_left_bearing;
+				y1a = CONTROL1(t).y + ugs_descend;
+				x3a = CONTROL2(t).x + ugs_left_bearing;
+				y3a = CONTROL2(t).y + ugs_descend;
+				x3 = END_POINT(t).x + ugs_left_bearing;
+				y3 = END_POINT(t).y + ugs_descend;
+				ix3 = round (x3);
+				iy3 = round (y3);
+
+				cubic_to_quadratic (x1, y1, x1a, y1a, x3a, y3a, x3, y3,
+					&x1a, &y1a, &x2, &y2, &x3a, &y3a);
+				ix1a = round (x1a);
+				iy1a = round (y1a);
+				ix2 = round (x2);
+				iy2 = round (y2);
+				ix3a = round (x3a);
+				iy3a = round (y3a);
+
+				if (! (ix1a == round(x1) && iy1a == round(y1)) &&
+				    ! (ix1a == ix2 && iy1a == iy2))
+					fprintf (file, "\t\t\tdot-off %d %d\n", ix1a, iy1a);
+
+				fprintf (file, "\t\t\tdot-on %d %d\n", ix2, iy2);
+
+				if (! (ix3a == ix2 && iy3a == iy2) &&
+				    ! (ix3a == ix3 && iy3a == iy3))
+					fprintf (file, "\t\t\tdot-off %d %d\n", ix3a, iy3a);
+
+				fprintf (file, "\t\t\tdot-on %d %d\n", ix3, iy3);
+
+				if (lowerx > ix1a) lowerx = ix1a;
+				if (lowery > iy1a) lowery = iy1a;
+				if (upperx < ix1a) upperx = ix1a;
+				if (uppery < iy1a) uppery = iy1a;
+
+				if (lowerx > ix2) lowerx = ix2;
+				if (lowery > iy2) lowery = iy2;
+				if (upperx < ix2) upperx = ix2;
+				if (uppery < iy2) uppery = iy2;
+
+				if (lowerx > ix3a) lowerx = ix3a;
+				if (lowery > iy3a) lowery = iy3a;
+				if (upperx < ix3a) upperx = ix3a;
+				if (uppery < iy3a) uppery = iy3a;
+
+				if (lowerx > ix3) lowerx = ix3;
+				if (lowery > iy3) lowery = iy3;
+				if (upperx < ix3) upperx = ix3;
+				if (uppery < iy3) uppery = iy3;
+			}
+			x1 = x3;
+			y1 = y3;
+		}
+		fprintf (file, "\t\tend path\n");
+	}
+	fprintf (file, "\tend contour\n");
+}
+
+int output_ugs_writer (FILE* file, at_string name,
+	int llx, int lly, int urx, int ury, at_output_opts_type *opts,
+	spline_list_array_type shape, at_msg_func msg_func,
+	at_address msg_data)
+{
+	/* Write the header.  */
+	fprintf (file, "symbol %#x design-size %ld\n",
+		ugs_charcode, ugs_design_pixels);
+	fprintf (file, "\tadvance-width %d\n", ugs_advance_width);
+
+	upperx = ugs_advance_width - ugs_max_col - 1;
+	uppery = ugs_max_row;
+
+	lowerx = ugs_left_bearing;
+	upperx = ugs_advance_width - ugs_max_col - 1;
+	lowery = ugs_descend;
+	uppery = ugs_max_row;
+
+	output_splines (file, shape, ury - lly);
+
+	fprintf (file, "\tleft-bearing %ld\n", lowerx);
+	fprintf (file, "\tright-bearing %ld\n", ugs_advance_width - upperx - 1);
+	fprintf (file, "\tascend %ld\n", uppery + 1);
+	fprintf (file, "\tdescend %ld\n", lowery);
+
+	/* Write the trailer.  */
+	fputs ("end symbol\n\n", file);
+}
diff -u -N -b autotrace-0.31.1/output-ugs.h autotrace/output-ugs.h
--- autotrace-0.31.1/output-ugs.h	Thu Jan  1 03:00:00 1970
+++ autotrace/output-ugs.h	Thu May 22 18:56:37 2003
@@ -0,0 +1,38 @@
+/* output-ugs.h - output in UGS format
+
+   Copyright (C) 2003 Serge Vakulenko <vak@cronyx.ru>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+   USA. */
+
+#ifndef OUTPUT_UGS_H
+#define OUTPUT_UGS_H
+
+#include "output.h"
+
+int output_ugs_writer(FILE* file, at_string name,
+		      int llx, int lly, int urx, int ury,
+		      at_output_opts_type * opts,
+		      at_spline_list_array_type shape,
+		      at_msg_func msg_func,
+		      at_address msg_data);
+
+extern long ugs_charcode;
+extern long ugs_design_pixels;
+extern long ugs_advance_width;
+extern long ugs_left_bearing, ugs_descend;
+extern long ugs_max_col, ugs_max_row;
+
+#endif /* not OUTPUT_UGS_H */
diff -u -N -b autotrace-0.31.1/output.c autotrace/output.c
--- autotrace-0.31.1/output.c	Wed Nov  6 21:42:02 2002
+++ autotrace/output.c	Thu May 22 15:27:29 2003
@@ -32,6 +32,7 @@
 #include "output-p2e.h"
 #include "output-sk.h"
 #include "output-svg.h"
+#include "output-ugs.h"
 #include "output-fig.h"
 #ifdef HAVE_LIBSWF
 #include "output-swf.h"
@@ -60,6 +61,7 @@
     {"p2e",	"pstoedit frontend format",	output_p2e_writer},
     {"sk",	"Sketch",			output_sk_writer},
     {"svg",	"Scalable Vector Graphics",	output_svg_writer},
+    {"ugs",	"Unicode glyph source",		output_ugs_writer},
     {"fig",     "XFIG 3.2",                     output_fig_writer},
 #ifdef HAVE_LIBSWF
     {"swf",	"Shockwave Flash 3",		output_swf_writer},
